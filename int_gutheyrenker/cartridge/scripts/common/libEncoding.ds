
var dwgr = {php:{},grutil:{}};

function getGRUtils() {		
	return dwgr;	
}

(function(dwgr){
dwgr.php = {};
dwgr.grutil= {};
var php = dwgr.php;

// Private API functions used for in ported GR/PHP code
var STR_PAD_LEFT = "STR_PAD_LEFT";

// Utility functions referenced by GR code .. ported from PHP

function microtime(get_as_float) {
    // Returns either a string or a float containing the current time in seconds and microseconds  
    // 
    // version: 1107.2516
    // discuss at: http://phpjs.org/functions/microtime
    // +   original by: Paulo Freitas
    // *     example 1: timeStamp = microtime(true);
    // *     results 1: timeStamp > 1000000000 && timeStamp < 2000000000
    var now = new Date().getTime();// / 1000;
	var nowsecs = now/1000; // seconds
    var s = parseInt(nowsecs, 10); // int seconds
 
    return (get_as_float) ? nowsecs : (nowsecs - s).toFixed(8) + ' ' + s;
}

dwgr.grutil.microtime = function(){return microtime(false);};

// IN: int val < 62^6, 
// RET: 6 char str conv to base62 [0-9A-Za-z]
//
function to_base62 (in_val) {
	var tval = in_val ;

	var x6   = intval(tval / 916132832) ;
	tval -= x6 * 916132832 ;
	var x5   = intval(tval / 14776336) ;
	tval -= x5 * 14776336 ;
	var x4   = intval(tval / 238328) ;
	tval -= x4 * 238328 ;
	var x3   = intval(tval / 3844) ;
	tval -= x3 * 3844 ;
	var x2   = intval(tval / 62) ;
	tval -= x2 * 62 ;

	var out_str = 
		b62_single62( x6 ) +
		b62_single62( x5 ) +
		b62_single62( x4 ) +
		b62_single62( x3 ) +
		b62_single62( x2 ) +
		b62_single62( intval(tval) ) ;

	return out_str ;
}

dwgr.grutil.to_base62 = function(inVar){ return to_base62(inVar); }

function b62_single62 (in_val) {
	if ( in_val < 10 ) { return in_val ; }
	if ( in_val < 36 ) { return chr( in_val + 55 ) ; }
	if ( in_val < 62 ) { return chr( in_val + 61 ) ; }

	return "0" ;
}

function utf8_decode (str_data) {
    // Converts a UTF-8 encoded string to ISO-8859-1  
	var tmp_arr = [],
        i = 0,
        ac = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;
 
    str_data += '';
 
    while (i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if (c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if (c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    } 
    return tmp_arr.join('');
}

function utf8_encode (argString) {
    // Encodes an ISO-8859-1 string to UTF-8  
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
    var string = (argString + ''); // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var utftext = "",
        start, end, stringl = 0;
 
    start = end = 0;
    stringl = string.length;
    for (var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;
         
		if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        } else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    } 
    if (end > start) {
        utftext += string.slice(start, stringl);
    }
    
	return utftext;
}

function base64_decode (data) {
    // Decodes string using MIME base64 algorithm  
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        dec = "",
        tmp_arr = [];
 
    if (!data) {
        return data;    }
 
    data += '';
 
    do { 
	// unpack four hexets into three octets using index points in b64
        h1 = b64.indexOf(data.charAt(i++));
        h2 = b64.indexOf(data.charAt(i++));
        h3 = b64.indexOf(data.charAt(i++));
        h4 = b64.indexOf(data.charAt(i++));
        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
 
        o1 = bits >> 16 & 0xff;
        o2 = bits >> 8 & 0xff;
        o3 = bits & 0xff; 
        if (h3 == 64) {
            tmp_arr[ac++] = String.fromCharCode(o1);
        } else if (h4 == 64) {
            tmp_arr[ac++] = String.fromCharCode(o1, o2);
        } else {
            tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
        }
    } while (i < data.length);
     
	dec = tmp_arr.join('');
    dec = utf8_decode(dec);
 
    return dec;
}

function base64_encode (data) {
    // Encodes string using MIME base64 algorithm  
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        enc = "",
        tmp_arr = [];
     if (!data) {
        return data;
    }
 
    data = utf8_encode(data + ''); 
    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++); 
        bits = o1 << 16 | o2 << 8 | o3;
 
        h1 = bits >> 18 & 0x3f;
        h2 = bits >> 12 & 0x3f;
        h3 = bits >> 6 & 0x3f;
        h4 = bits & 0x3f;
 
        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);
 
    enc = tmp_arr.join('');
 
    switch (data.length % 3) {
    case 1:
        enc = enc.slice(0, -2) + '==';
        break;
    case 2:
        enc = enc.slice(0, -1) + '=';
        break;
    }
 
    return enc;
}

function strcmp (str1, str2) {
    return ((str1 == str2) ? 0 : ((str1 > str2) ? 1 : -1));
}

function strnatcmp (f_string1, f_string2, f_version) {
    var i = 0;
 
    if (f_version == undefined) {
        f_version = false;
    }
 
    var __strnatcmp_split = function (f_string) {
        var result = [];
        var buffer = '';
        var chr = '';
        var i = 0,
            f_stringl = 0;
 
        var text = true; 
        f_stringl = f_string.length;
        for (i = 0; i < f_stringl; i++) {
            chr = f_string.substring(i, i + 1);
            if (chr.match(/\d/)) {
                if (text) {
                    if (buffer.length > 0) {
                        result[result.length] = buffer;
                        buffer = '';
                    } 
                    text = false;
                }
                buffer += chr;
            } else if ((text == false) && (chr == '.') && (i < (f_string.length - 1)) && (f_string.substring(i + 1, i + 2).match(/\d/))) {
                result[result.length] = buffer;
                buffer = '';
            } else {
                if (text == false) {
                    if (buffer.length > 0) {
                        result[result.length] = parseInt(buffer, 10);
                        buffer = '';
                    }
                    text = true;
                }
                buffer += chr;
            }
        }
 
        if (buffer.length > 0) {
            if (text) {
                result[result.length] = buffer;
            } else {
                result[result.length] = parseInt(buffer, 10);
            }
        }
 
        return result;
    };
    var array1 = __strnatcmp_split(f_string1 + '');
    var array2 = __strnatcmp_split(f_string2 + '');
 
    var len = array1.length;
    var text = true; 
    var result = -1;
    var r = 0;
 
    if (len > array2.length) {
        len = array2.length;
        result = 1;
    }
 
    for (i = 0; i < len; i++) {        
		if (isNaN(array1[i])) {
            if (isNaN(array2[i])) {
                text = true;
 
                if ((r = strcmp(array1[i], array2[i])) != 0) {
                    return r;
                }
            } else if (text) {
                return 1;
            } else {
                return -1;
            }
        } else if (isNaN(array2[i])) {
            if (text) {
                return -1;
            } else {
                return 1;
            }
        } else {
            if (text || f_version) {
                if ((r = (array1[i] - array2[i])) != 0) {
                    return r;
                }
            } else {
                if ((r = strcmp(array1[i].toString(), array2[i].toString())) != 0) {
                    return r;
                }
            }
 
            text = false;
        }
    }
 
    return result;
}

function krsort (inputArr, sort_flags) {
    // Sort an array by key value in reverse order  
    var tmp_arr = {},
        keys = [],
        sorter, i, k,
        strictForIn = false,
        populateArr = {};
 
    switch (sort_flags) {
    case 'SORT_STRING':
        // compare items as strings
        sorter = function (a, b) {
            return strnatcmp(b, a);
        };
        break;
    // case 'SORT_LOCALE_STRING':        // compare items as strings, based on the current locale (set with  i18n_loc_set_default() as of PHP6)
    //     var loc = this.i18n_loc_get_default();
    //     sorter = this.php_js.i18nLocales[loc].sorting;
    //     break;
    case 'SORT_NUMERIC':        // compare items numerically
        sorter = function (a, b) {
            return (b - a);
        };
        break;
    case 'SORT_REGULAR':
        // compare items normally (don't change types)
    default:
        sorter = function (b, a) {
            var aFloat = parseFloat(a),
                bFloat = parseFloat(b),
                aNumeric = aFloat + '' === a,
                bNumeric = bFloat + '' === b;
            if (aNumeric && bNumeric) {
                return aFloat > bFloat ? 1 : aFloat < bFloat ? -1 : 0;
            } else if (aNumeric && !bNumeric) {
                return 1;
            } else if (!aNumeric && bNumeric) {
                return -1;
            }
            return a > b ? 1 : a < b ? -1 : 0;
        };
        break;
    }
     // Make a list of key names
    for (k in inputArr) {
        if (inputArr.hasOwnProperty(k)) {
            keys.push(k);
        }
    }
    keys.sort(sorter);
 
    // BEGIN REDUNDANT
    //this.php_js = this.php_js || {};
    //this.php_js.ini = this.php_js.ini || {};
    // END REDUNDANT
    strictForIn = true;//this.php_js.ini['phpjs.strictForIn'] && this.php_js.ini['phpjs.strictForIn'].local_value && this.php_js.ini['phpjs.strictForIn'].local_value !== 'off';
    populateArr = strictForIn ? inputArr : populateArr;
  
    // Rebuild array with sorted key names
    for (i = 0; i < keys.length; i++) {
        k = keys[i];
        tmp_arr[k] = inputArr[k];
        if (strictForIn) {
            delete inputArr[k];
        }
    }
    for (i in tmp_arr) {
        if (tmp_arr.hasOwnProperty(i)) {
            populateArr[i] = tmp_arr[i];
        }
    }
    
	return strictForIn || populateArr;
}

function strtr(str, from, to) {
    // Translates characters in str using given translation tables  
    var fr = '',
        i = 0,
        j = 0,
        lenStr = 0,
        lenFrom = 0,
        tmpStrictForIn = false,
        fromTypeStr = '',
        toTypeStr = '',
        istr = '';
    var tmpFrom = [];
    var tmpTo = [];
    var ret = '';
    var match = false;
 
    // Received replace_pairs?
    // Convert to normal from->to chars
    if (typeof from === 'object') {
        tmpStrictForIn = true;//this.ini_set('phpjs.strictForIn', false); // Not thread-safe; temporarily set to true
        //from = krsort(from);
        //this.ini_set('phpjs.strictForIn', tmpStrictForIn);
        for (fr in from) {
            if (from.hasOwnProperty(fr)) {
                tmpFrom.push(fr);
                tmpTo.push(from[fr]);
            }
        }
 
        from = tmpFrom;
        to = tmpTo;
    } 

    // Walk through subject and replace chars when needed
    lenStr = str.length;
    lenFrom = from.length;
    fromTypeStr = typeof from === 'string';
    toTypeStr = typeof to === 'string';
 
    for (i = 0; i < lenStr; i++) {
        match = false;
        if (fromTypeStr) {
            istr = str.charAt(i);
            for (j = 0; j < lenFrom; j++) {
                if (istr == from.charAt(j)) {
                    match = true;
                    break;
                }
            }
        } else {
            for (j = 0; j < lenFrom; j++) {
                if (str.substr(i, from[j].length) == from[j]) {
                    match = true;
                    // Fast forward
                    i = (i + from[j].length) - 1;
                    break;
                }
            }
        }

        if (match) {
            ret += toTypeStr ? to.charAt(j) : to[j];
        } else {
            ret += str.charAt(i);
        }
    }
 
    return ret;
}

function strlen(astring) { 
	// PEP: not meant for unicode characters
    return astring.length;
}

function substr(str, start, len) {
	str += '';
	var end = str.length;
    if (start < 0) {
        start += end;
    }
//	str += '';
    end = typeof len === 'undefined' ? end : (len < 0 ? len + end : len + start);
    // PHP returns false if start does not fall within the string.
    // PHP returns false if the calculated end comes before the calculated start.
    // PHP returns an empty string if start and end are the same.
    // Otherwise, PHP returns the portion of the string from start to end.
    return start >= str.length || start < 0 || start > end ? !1 : str.slice(start, end);
}

function array_flip (trans) {
    // Return array with key <-> value flipped  
    // 
    // version: 1107.2516
    // discuss at: http://phpjs.org/functions/array_flip
    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      improved by: Pier Paolo Ramon (http://www.mastersoup.com/)
    // *     example 1: array_flip( {a: 1, b: 1, c: 2} );
    // *     returns 1: {1: 'b', 2: 'c'}
    var key, tmp_ar = {};
 
    for (key in trans) {
        if (!trans.hasOwnProperty(key)) {continue;}
        tmp_ar[trans[key]] = key;
    }
 
    return tmp_ar;
}

function base_convert (anumber, frombase, tobase) {
    // Converts a number in a string from any base <= 36 to any base <= 36  
    var parsedInt = parseInt(anumber + '', frombase);
    var stringRep = parsedInt.toString(tobase);
    return stringRep;
}

function str_pad (input, pad_length, pad_string, pad_type) {
    // Returns input string padded on the left or right to specified length with pad_string  
    var half = '',
        pad_to_go; 

    var str_pad_repeater = function (s, len) {
        var collect = '',
            i;
        while (collect.length < len) {
            collect += s;
        }
        collect = collect.substr(0, len);

        return collect;
    };
 
    input += '';
    pad_string = pad_string !== undefined ? pad_string : ' '; 
    if (pad_type != 'STR_PAD_LEFT' && pad_type != 'STR_PAD_RIGHT' && pad_type != 'STR_PAD_BOTH') {
        pad_type = 'STR_PAD_RIGHT';
    }
    if ((pad_to_go = pad_length - input.length) > 0) {
        if (pad_type == 'STR_PAD_LEFT') {
            input = str_pad_repeater(pad_string, pad_to_go) + input;
        } else if (pad_type == 'STR_PAD_RIGHT') {
            input = input + str_pad_repeater(pad_string, pad_to_go);
        } else if (pad_type == 'STR_PAD_BOTH') {
            half = str_pad_repeater(pad_string, Math.ceil(pad_to_go / 2));
            input = half + input + half;
            input = input.substr(0, pad_length);
        }
    } 
    return input;
}

function strtoupper (str) {
    // Makes a string uppercase  
    // 
    // version: 1107.2516
    // discuss at: http://phpjs.org/functions/strtoupper    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Onno Marsman
    // *     example 1: strtoupper('Kevin van Zonneveld');
    // *     returns 1: 'KEVIN VAN ZONNEVELD'
    return (str + '').toUpperCase();
}

function str_replace (search, replace, subject) {//, count) {
    // Replaces all occurrences of search in haystack with replace  
    var i = 0,
        j = 0,
        temp = '',
        repl = '',
        sl = 0,        fl = 0,
        f = [].concat(search),
        r = [].concat(replace),
        s = subject,
        ra = Object.prototype.toString.call(r) === '[object Array]',
        sa = Object.prototype.toString.call(s) === '[object Array]';
    s = [].concat(s);
    // if (count) {
    //     this.window[count] = 0;
    // }

    for (i = 0, sl = s.length; i < sl; i++) {
        if (s[i] === '') {
            continue;
        }
        for (j = 0, fl = f.length; j < fl; j++) {
            temp = s[i] + '';
            repl = ra ? (r[j] !== undefined ? r[j] : '') : r[0];
            s[i] = (temp).split(f[j]).join(repl);
            // if (count && s[i] !== temp) {
            //     this.window[count] += (temp.length - s[i].length) / f[j].length;
            // }
        }
    }
    return sa ? s : s[0];
}

function chr (codePt) {
    // Converts a codepoint number to a character  
    if (codePt > 0xFFFF) { 
	// Create a four-byte string (length 2) since this code point is high
        return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));
    }
    return String.fromCharCode(codePt);
}
function intval (mixed_var, base) {
    // Get the integer value of a variable using the optional base for the conversion  
    var tmp;
 
    var type = typeof(mixed_var);
    
	if (type === 'boolean') {
        return +mixed_var;
    } else if (type === 'string') {
        tmp = parseInt(mixed_var, base || 10);
        return (isNaN(tmp) || !isFinite(tmp)) ? 0 : tmp;
    } else if (type === 'number' && isFinite(mixed_var)) {
        return mixed_var | 0;
    } else {
        return 0;
    }
}

function gettype (mixed_var) {
    // Returns the type of the variable  
    var s = typeof mixed_var,
        name;
    var getFuncName = function (fn) {
        var name = (/\W*function\s+([\w\$]+)\s*\(/).exec(fn);
        if (!name) {
            return '(Anonymous)';
        }
        return name[1];
    };
    if (s === 'object') {
        if (mixed_var !== null) { // From: http://javascript.crockford.com/remedial.html
            if (typeof mixed_var.length === 'number' && !(mixed_var.propertyIsEnumerable('length')) && typeof mixed_var.splice === 'function') {
                s = 'array';
            } else if (mixed_var.constructor && getFuncName(mixed_var.constructor)) {
                name = getFuncName(mixed_var.constructor);
                if (name === 'Date') {
                    s = 'date'; // not in PHP
                } else if (name === 'RegExp') {
                    s = 'regexp'; // not in PHP
                } else if (name === 'PHPJS_Resource') { // Check against our own resource constructor
                    s = 'resource';
                }
            }
        } else {
            s = 'null';
        }
    } else if (s === 'number') {
        s = is_float(mixed_var) ? 'double' : 'integer';
    }
    return s;
}

function is_float (mixed_var) {
    // Returns true if variable is float point  
    return +mixed_var === mixed_var && !!(mixed_var % 1);
}

function md5 (str) {
    // Calculate the md5 hash of a string  
    // 
    // version: 1107.2516
    // discuss at: http://phpjs.org/functions/md5    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // + namespaced by: Michael White (http://getsprink.com)
    // +    tweaked by: Jack
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Brett Zamir (http://brett-zamir.me)    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // -    depends on: utf8_encode
    // *     example 1: md5('Kevin van Zonneveld');
    // *     returns 1: '6e658d4bfcb59cc13f96c14450ac40b9'
    var xl; 
    var rotateLeft = function (lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    };
     var addUnsigned = function (lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = (lX & 0x80000000);
        lY8 = (lY & 0x80000000);
        lX4 = (lX & 0x40000000);
        lY4 = (lY & 0x40000000);
        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
        if (lX4 & lY4) {
            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        }        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            } else {
                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);            }
        } else {
            return (lResult ^ lX8 ^ lY8);
        }
    }; 
    var _F = function (x, y, z) {
        return (x & y) | ((~x) & z);
    };
    var _G = function (x, y, z) {
        return (x & z) | (y & (~z));
    };
    var _H = function (x, y, z) {
        return (x ^ y ^ z);
    };    
	var _I = function (x, y, z) {
        return (y ^ (x | (~z)));
    };
 
    var _FF = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };
 
    var _GG = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };
 
    var _HH = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };
 
    var _II = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };
 
    var convertToWordArray = function (str) {        var lWordCount;
        var lMessageLength = str.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = new Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (str.charCodeAt(lByteCount) << lBytePosition));
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;    };
 
    var wordToHex = function (lValue) {
        var wordToHexValue = "",
            wordToHexValue_temp = "",
            lByte, lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            wordToHexValue_temp = "0" + lByte.toString(16);
            wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
        }
        return wordToHexValue;
    };
 
    var x = [],        
		k, AA, BB, CC, DD, a, b, c, d, S11 = 7,
        S12 = 12,
        S13 = 17,
        S14 = 22,
        S21 = 5,
        S22 = 9,
        S23 = 14,
        S24 = 20,
        S31 = 4,
        S32 = 11,
        S33 = 16,
        S34 = 23,
        S41 = 6,
        S42 = 10,
        S43 = 15,
        S44 = 21;
 
    str = utf8_encode(str);
    x = convertToWordArray(str);
    a = 0x67452301;
    b = 0xEFCDAB89;
    c = 0x98BADCFE;
    d = 0x10325476;
 
    xl = x.length;
    for (k = 0; k < xl; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;        a = _FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = _FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = _FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = _FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = _FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = _FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = _FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = _FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = _FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = _FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = _FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = _FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = _FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = _FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = _FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = _FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = _GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = _GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = _GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = _GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = _GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = _GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = _GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = _GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = _GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = _GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = _GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = _GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = _GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = _GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = _GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = _GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = _HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = _HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = _HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = _HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = _HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = _HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = _HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = _HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = _HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = _HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = _HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = _HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = _HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = _HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = _HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = _HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = _II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = _II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = _II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = _II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = _II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = _II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = _II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = _II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = _II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = _II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = _II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = _II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = _II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = _II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = _II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = _II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = addUnsigned(a, AA);
        b = addUnsigned(b, BB);
        c = addUnsigned(c, CC);
        d = addUnsigned(d, DD);
    }
    var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
 
    return temp.toLowerCase();
}

function preg_match (pattern, subject, matches, flags, offset) {
    // http://kevin.vanzonneveld.net
    // +   original by: Francis Lewis
    // +   improved by: Brett Zamir (http://brett-zamir.me)
    // *     example 1: matches = [];
    // *     example 1: preg_match(/(\w+)\W([\W\w]+)/, 'this is some text', matches);
    // *     matches 1: matches[1] == 'this'
    // *     returns 1: 1

    // UNFINISHED
    // Just found something we should take a very serious look at Steve Levithan's XRegExp which implements Unicode classes and two extra flags: http://blog.stevenlevithan.com/archives/xregexp-javascript-regex-constructor
    // Before finding this, I was working on a script to search through an SQLite database to build our Unicode expressions automatically; I may finish that as it should be expandable for the future, and be an extra eye to confirm Steve's work
    // Also need to look at/integrate with Michael Grier's http://mgrier.com/te5t/preg_match_all.js ; http://mgrier.com/te5t/testpma.html ; http://mgrier.com/te5t/testpma.php

    var i=0, lastDelimPos=-1, flag='', patternPart='', flagPart='', array = [], regexpFlags='', subPatternNames=[];
    var getFuncName = function (fn) {
        var name=(/\W*function\s+([\w\$]+)\s*\(/).exec(fn);
        if (!name) {
            return '(Anonymous)';
        }
        return name[1];
    };

    var join = function (arr) {
        return '(?:'+arr.join('|')+')';
    };

    if (typeof pattern === 'string') {
        if (pattern === '') {
            // Handle how?
        }

        lastDelimPos = pattern.lastIndexOf(pattern[0]);
        if (lastDelimPos === 0) { // convenience to allow raw string without delimiters  // || a-zA-Z/.test(pattern[0]) || pattern.length === 1) { // The user is probably not using letters for delimiters (not recommended, but could be convenient for non-flagged expressions)
            pattern = new RegExp(pattern);
        }
        else {
            patternPart = pattern.slice(1, lastDelimPos);
            flagPart = pattern.slice(lastDelimPos+1);
            // Fix: Need to study http://php.net/manual/en/regexp.reference.php more thoroughly
            // e.g., internal options i, m, s, x, U, X, J; conditional subpatterns?, comments, recursive subpatterns,
            for (i=0; i < flagPart.length; i++) {
                flag = flagPart[i];
                switch (flag) {
                    case 'g': // We don't use this in preg_match, but it's presumably not an error
                    case 'm':
                    case 'i':
                        regexpFlags += flag;
                        break;
                    case 'e': // used in preg_replace only but ignored elsewhere; "does normal substitution of backreferences in the replacement string, evaluates it as PHP code, and uses the result for replacing the search string". "Single quotes, double quotes, backslashes and NULL chars will be escaped by backslashes in substituted backreferences."
                        // Safely ignorable
                        break;
                    case 's': // "dot metacharacter in the pattern matches all characters, including newlines. Without it, newlines are excluded... A negative class such as [^a] always matches a newline character"
                    case 'x': // "whitespace data characters in the pattern are totally ignored except when escaped or inside a character class, and characters between an unescaped # outside a character class and the next newline character, inclusive, are also ignored"; "Whitespace characters may never appear within special character sequences in a pattern"
                    case 'A': // pattern is "constrained to match only at the start of the string which is being searched"
                    case 'D': // "a dollar metacharacter in the pattern matches only at the end of the subject string" (ignored if 'm' set)
                    case 'U': // "makes not greedy by default, but become greedy if followed by "?""
                    case 'J': // "changes the local PCRE_DUPNAMES option. Allow duplicate names for subpatterns"
                    case 'u': // "turns on additional functionality of PCRE that is incompatible with Perl. Pattern strings are treated as UTF-8."
                        throw 'The passed flag "'+flag+'" is presently unsupported in '+getFuncName(arguments.callee);
                    case 'X': // "additional functionality of PCRE that is incompatible with Perl. Any backslash in a pattern that is followed by a letter that has no special meaning causes an error, thus reserving these combinations for future expansion"; not in use in PHP presently
throw 'X flag is unimplemented at present';
                        if (/\/([^\\^$.[\]|()?*+{}aefnrtdDhHsSvVwWbBAZzGCcxkgpPX\d])/.test(patternPart)) { // can be 1-3 \d together after backslash (as one unit)
                            // \C = single byte (useful in 'u'/UTF8 mode)
                            // CcxpPXkg are all special uses;
                            //c. (any character after 'c' for control character)
                            // x[a-fA-F\d][a-fA-F\d] (hex)
                            // "Back references to the named subpatterns can be achieved by (?P=name) or, since PHP 5.2.4, also by \k<name>, \k'name', \k{name} or \g{name}"
                            // Unicode classes (with u flag only)
                                // p{} | P{} (case insensitive does not affect)
                                // [CLMNPSZ]
                                // C|Cc|Cf|Cn|Co|Cs|L|Ll|Lm|Lo|Lt|Lu|M|Mc|Me|Mn|N|Nd|Nl|No|P|Pc|Pd|Pe|Pf|Pi|Po|Ps|S|Sc|Sk|Sm|So|Z|Zl|Zp|Zs

                                 // Other, Control
                                // Cc = '[\u0000-\u001f\u007f-\u009f]';
                                // Other, Format
                                // Cf = '(?:[\u00ad\u0600-\u0603\u06dd\u070f\u17b4-\u17b5\u200b-\u200f\u202a-\u202e\u2060-\u2064\u206a-\u206f\ufeff\ufff9-\ufffb]|[\ud834][\udd73-\udd7a]|[\udb40][\udc01\udc20-\udc58]'); /* latter surrogates represent 1d173-1d17a, e0001, e0020-e0058 */
                                // Other, Unassigned
// Cn = TO-DO;
                                // Other, Private use
                                // Co = '(?:[\ue000-\uf8ff]|[\udb80-\udbbe][\udc00-\udfff]|[\udbff][\udc00-\udffd]|[\udbc0-\udbfe][\udc00-\udfff]|[\udbff][\udc00-\udffd])';  // f0000-ffffd, 100000-10fffd
                                // Other, Surrogate
                                // Cs = '[\ud800-\udb7f\udb80-\udbff\udc00-\udfff]';

// Need to finish Cn (above) and Ll-Sm here below
                                // Letter, Lower case
                                // Ll = '[]';
                                // Letter, Modifier
                                // Lm =
                                // Letter, Other
                                // Lo =
                                // Letter, Title case
                                // Lt =
                                // Letter, Upper case
                                // Lu =
                                // Mark, Spacing
                                // Mc =
                                // Mark, Enclosing
                                // Me =
                                // Mark, Non-spacing
                                // Mn =
                                // Number, Decimal
                                // Nd =
                                // Number, letter
                                // Nl =
                                // Number, Other
                                // No =
                                // Punctuation, Connector
                                // Pc =
                                // Punctuation, Dash
                                // Pd =
                                // Punctuation, Close
                                // Pe =
                                // Punctuation, Final
                                // Pf =
                                // Punctuation, Initial
                                // Pi =
                                // Punctuation, Other
                                // Po =
                                // Punctuation, Open
                                // Ps =
                                // Symbol, Currency
                                // Sc =
                                // Symbol, Modifier
                                // Sk =
                                // Symbol, Mathematical
                                // Sm ='\u002b\u003c-\u003e\u007c\u007e\u00ac\u00b1\u00d7\u00f7\u03f6\u0606-\u0608\u2044\u2052\u207a-\u207c\u208a-\u208c\u2140-\u2144\u214b\u2190-\u2194\u219a\u219b\u21a0\u21a3\u21a6\u21ae\u21ce\u21cf\u21d2\u21d4\u21f4-\u22ff\u2308-\u230b\u2320\u2321\u237c\u239b-\u23b3\u23dc-\u23e1\u25b7\u25c1\u25f8-\u25ff\u266f\u27c0-\u27c4\u27c7-\u27ca\u27cc\u27d0-\u27e5\u27f0-\u27ff\u2900-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2aff\u2b30-\u2b44\u2b47-\u2b4c\ufb29\ufe62\ufe64-\ufe66\uff0b\uff1c-\uff1e\uff5c\uff5e\uffe2\uffe9-\uffec

                                // 1d6c1 1d6db 1d6fb 1d715 1d735 1d74f 1d76f 1d789 1d7a9 1d7c3

                                // Symbol, Other
                                // latter alternates are surrogate pairs comprising 10102, 10137-1013f, 10179-10189, 10190-1019b, 101d0-101fc, 1d000-1d0f5, 1d100-1d126, 1d129-1d164, 1d16a-1d16c, 1d183-1d184, 1d18c-1d1a9, 1d1ae-1d1dd, 1d200-1d241, 1d245, 1d300-1d356, 1f000-1f02b, 1f030-1f093
                                // So = '(?:[\u00a6\u00a7\u00a9\u00ae\u00b0\u00b6\u0482\u060e\u060f\u06e9\u06fd\u06fe\u07f6\u09fa\u0b70\u0bf3-\u0bf8\u0bfa\u0c7f\u0cf1\u0cf2\u0d79\u0f01-\u0f03\u0f13-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u109e\u109f\u1360\u1390-\u1399\u1940\u19e0-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u214a\u214c\u214d\u214f\u2195-\u2199\u219c-\u219f\u21a1\u21a2\u21a4\u21a5\u21a7-\u21ad\u21af-\u21cd\u21d0\u21d1\u21d3\u21d5-\u21f3\u2300-\u2307\u230c-\u231f\u2322-\u2328\u232b-\u237b\u237d-\u239a\u23b4-\u23db\u23e2-\u23e7\u2400-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u25b6\u25b8-\u25c0\u25c2-\u25f7\u2600-\u266e\u2670-\u269d\u26a0-\u26bc\u26c0-\u26c3\u2701-\u2704\u2706-\u2709\u270c-\u2727\u2729-\u274b\u274d\u274f-\u2752\u2756\u2758-\u275e\u2761-\u2767\u2794\u2798-\u27af\u27b1-\u27be\u2800-\u28ff\u2b00-\u2b2f\u2b45\u2b46\u2b50-\u2b54\u2ce5-\u2cea\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3243\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u32fe\u3300-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua828-\ua82b\ufdfd\uffe4\uffe8\uffed\uffee\ufffc\ufffd]|(?:\ud800[\udd02\udd37-\udd3f\udd79-\udd89\udd90-\udd9b\uddd0-\uddfc])|(?:\ud834[\udc00-\udcf5\udd00-\udd26\udd29-\udd64\udd6a-\udd6c\udd83-\udd84\udd8c-\udda9\uddae-\udddd\ude00-\ude41\ude45\udf00-\udf56])|(?:\ud83c[\udc00-\udc2b\udc30-\udc93]))';

                                // Separator, Line
                                // Zl = '[\u2028]';
                                // Separator, Paragraph
                                // Zp = '[\u2029]';
                                // Separator, Space
                                // Zs = '[\u0020\u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]';

                                // Form broader groups
                                // C = join([Cc, Cf, Cn, Co, Cs]);
                                // L = join([Ll, Lm, Lo, Lt, Lu]);
                                // M = join([Mc, Me, Mn]);
                                // N = join([Nd, Nl, No]);
                                // P = join([Pc, Pd, Pe, Pf, Pi, Po, Ps]);
                                // S = join([Sc, Sk, Sm, So]);
                                // Z = join([Zl, Zp, Zs]);
                                

                                // \X = (?>\PM\pM*)
                                // "Extended properties such as "Greek" or "InMusicalSymbols" are not supported by PCRE."
                            throw 'You are in "X" (PCRE_EXTRA) mode, using a reserved and presently unused escape sequence in '+getFuncName(arguments.callee);
                        }
                        break;
                    case 'S': // spends "more time analyzing pattern in order to speed up the time taken for matching" (for subsequent matches)
                        throw 'The passed flag "'+flag+'" to '+getFuncName(arguments.callee)+' cannot be implemented in JavaScript'; // Could possibly optimize inefficient expressions, however
                    case 'y':
                        throw 'Flag "y" is a non-cross-browser, non-PHP flag, not supported in '+getFuncName(arguments.callee);
                    default:
                        throw 'Unrecognized flag "'+flag+'" passed to '+getFuncName(arguments.callee);
                }
            }
        }
    }
    else {
        patternPart = pattern.source; // Allow JavaScript type expressions to take advantage of named subpatterns, so temporarily convert to string
        regexpFlags += pattern.global ? 'g' : '';
        regexpFlags += pattern.ignoreCase ? 'i' : '';
        regexpFlags += pattern.multiline ? 'm' : '';
    }

    patternPart = patternPart.replace(/\(\?<(.*?)>(.*?)\)/g, function (namedSubpattern, name, pattern) {
        subPatternNames.push(name);
        return '('+pattern+')';
    });

    pattern = new RegExp(patternPart, regexpFlags);

    // store the matches in the first index of the array
    array[0] = pattern.exec(subject);

    if (!array[0]) {
        return 0;
    }

    // If the user passed in a RegExp object or literal, we will probably need to reflect on
    //   its source, ignoreCase, global, and multiline properties to form a new expression (as above?),
    //   and use lastIndex
    if (offset) {
        // Not implemented
    }
    if (flags === 'PREG_OFFSET_CAPTURE' || flags === 256) { // Fix: make flags as number and allow bitwise AND checks against flags; see pathinfo()
        // Not implemented
        return 1; // matches will need to be different, so we return early here
    }

    // loop through the first indice of the array and store the values in the $matches array
    for (i = 0; i < array[0].length; i++) {
        matches[i] = array[0][i];
        if (i > 0 && subPatternNames[i-1] !== undefined) {
            matches[subPatternNames] = array[0][i]; // UNTESTED
        }
    }

    return 1;
}

dwgr.php.GR_Encode = function() {
	this._encodeMap= {
		'0'	: 'W',
		'1'	: 'X',
		'i'	: 'Y',
		'o'	: 'Z',
		'I'	: 'Y',
		'O'	: 'Z'
	};
	this._encode64Map= {
		'+'	: '-',
		'/'	: '_',
		'='	: '.'
	};

	this._decodeMap = array_flip(this._encodeMap);
	this._decode64Map = array_flip(this._encode64Map);
}

dwgr.php.GR_Encode.prototype = {
	base2ToBase32 : function(base2) {
    	var rv = '',s,s2;
    	var bits = strlen(base2);

    	for (var i = 0; i < bits; i += 5) {
			s = substr(base2, i, 5);
			s2 = base_convert(s, 2, 32);
			rv += s2;
		}

		encoded = strtr(strtoupper(rv), this._encodeMap);

		return encoded;
    },
	base32ToBase2: function(base32) {
		var rv = '',s,s2;
		var bits = strlen(base32);

		var decoded = strtr(strtoupper(base32), this._decodeMap);
		var converted = null;//;
		
    	for (var i = 0; i < bits; ++i) {
			s = substr(decoded, i, 1);
			converted = base_convert(s, 32, 2);
			s2 = str_pad(converted, 5, '0', STR_PAD_LEFT);
			rv += s2;
		}

		return rv;
    },
	base2ToBase64: function(base2) {
    	var bytes = '',n,s,s2;
    	var len = strlen(base2);
		var chars = 8, ds ='';

    	for (var i = len; i > 0; i -= 8) {
			n = i - 8;
			if (n < 0) {
				chars = 8 + n;
				n = 0;
			}
			s = substr(base2, n, chars);
			s2 = base_convert(s, 2, 10);
			bytes = chr(s2) + bytes;
			ds += "loop: "+s+":"+s2+":"+bytes+":"+chr(s2)+":"+ord(chr(s2))+"\n";
		}

		var base64 = dw.util.StringUtils.encodeBase64(bytes,'iso-8859-1');

		var encoded = strtr(base64, this._encode64Map);

		encoded = str_replace('.', '', encoded);

		return encoded;
    },
	base64ToBase2: function(base64) {
		var decoded = strtr(base64, this._decode64Map);

		var	len = strlen(decoded);
		var	mod = len % 4;
		var imod = 4 - mod;
		if( mod > 0 ) {
			while (imod>0) {
				decoded += '=';
				imod--;
			}
		}
		
		//var data = base64_decode(decoded);
		var data = dw.util.StringUtils.decodeBase64(decoded,'iso-8859-1');
		
		var rv = '';
		len = strlen(data);
		
			var c;
			var s;
			var s2;

			var data_i;
			
    	for (var i = len - 1; i >= 0; --i) {
    		data_i = data[i];
			c = ord(data_i);
			s = base_convert(c, 10, 2);
			s2 = str_pad(s, 8, '0', STR_PAD_LEFT);
			rv = s2 + rv;
		}

		rv = ltrim(rv, '0');
		
		return rv;
    }

};

var GR_Auth_AbstractCode = {
	DEFAULT_KEY : 'yiey4eeJei2vohWie7toh1ohb6sohcho',
	DEFAULT_CHARS : 7,
	MIN_CHARS : 1,
	MAX_CHARS : 31
};

dwgr.php.GR_Auth_AbstractCode = function() {
	this._bitsPerChar = null;
	this._key = null;
	this._codes = null;
	this._id = null;
	this._chars= GR_Auth_AbstractCode.DEFAULT_CHARS;
	this._totalBits = null;
	this._idBits = null;
	this._hashBits = null;
	this._hashBytes = null;
	this._mask = null;

	var key = arguments.length >= 1 ? arguments[0] : GR_Auth_AbstractCode.DEFAULT_KEY;

    this._key = intval(key);
};

dwgr.php.GR_Auth_AbstractCode.prototype = {
	getKey: function() {
    	return this._key;
    },
	setKey: function(key) {
    	this._key = key;
    },
	getChars: function() {
		return this._chars;
	},
	setChars: function(chars) {
		if (preg_match('/\d+/', chars)) {
			chars =  chars;
		}
		if (gettype(chars) !== 'integer') {
			throw new Exception('Chars parameter must be an integer');
		}
				chars =  chars;
		if (chars < GR_Auth_AbstractCode.MIN_CHARS || chars > GR_Auth_AbstractCode.MAX_CHARS) {
			throw new Exception(sprintf('Chars parameter must be between %s and %s', GR_Auth_AbstractCode.MIN_CHARS, GR_Auth_AbstractCode.MAX_CHARS));
		}
		this._chars = chars;
		this._setVars();
	},
	getCodes: function() {
		return this._codes;
	},
	setCodes: function(codes) {
		if (preg_match('/\d+/', codes)) {
			codes =  codes;
		}
		if (gettype(codes) !== 'integer') {
			throw new Exception('Codes parameter must be an integer');
		}
		if (codes <= 0) {
			throw new Exception('Codes parameter must be greater than 0');
		}

		this._codes = codes;
		this._setVars();
	},
	getId: function() {
		return this._id;
	},
	setId: function(id) {
		if (preg_match('/\d+/', id)) {
			id =  id;
		}
		if (gettype(id) !== 'integer') {
			throw new Exception('ID parameter must be an integer');
		}
		if (id < 0) {
			throw new Exception('ID must be greater or equal to zero');
		}
		this._id = id;
	},
	_setVars: function() {
		var that = this;
		this._totalBits = this._chars * this._bitsPerChar;
		this._idBits = intval(Math.ceil(Math.log(this._codes)/Math.log(2)))+1;
		this._hashBits = this._totalBits - this._idBits;
		this._hashBytes =  intval(intval(this._hashBits + 7) / 8);
		
		this._mask = sprintf('%%0%db%%s', this._idBits);
// #printf("this->_totalBits=%s\n", $this->_totalBits);
// #printf("this->_idBits=%s\n", $this->_idBits);
// #printf("this->_hashBits=%s\n", $this->_hashBits);
// #printf("this->_hashBytes=%s\n", $this->_hashBytes);
// #printf("this->_mask=%s\n", $this->_mask);
	},
	getHash: function() {
		var id = arguments.length >= 1 ? arguments[0] : null;

// #printf(">>> gethash(%s)\n", $id);
		if (id == null) {
			id = this._id;
		}
		var that = this;
		var key = this._key;
		
		var ds = this._key + id+'\n';
		
		var hash = md5(this._key + id);
		var hash_b = '', hash8, h;
		for (i = 0; i < 8; ++i) {
			hash8 = substr(hash, 0 + i * 8, 8) || '0';

			h = str_pad(base_convert(hash8, 16, 2), 16, "0");
			hash_b += h;
		}
		var rv = substr(hash_b, 0, this._hashBits);
		return rv;
	},
	getCode: function() {
		var id = arguments.length >= 1 ? arguments[0] : null;

// #printf(">>> getCode(%s)\n", $id);
		if (id != null) {
			this.setId(id);
		}
		if (this._codes == null) {
			throw new Exception('Codes is a required attribute');
		}
		if (this._id == null) {
			throw new Exception('ID is a required attribute');
		}
		if (this._id >= this._codes) {
			throw new Exception(sprintf('ID must be less than %s', this._codes));
		}		

// #printf("id    =%s\n", $this->_id);
		var hash = this.getHash(this._id);
		
// #printf("hash       =%s\n", $hash);
// #printf("len(hash)  =%s\n", strlen($hash));

		var code = sprintf(this._mask, this._id, hash);
//#printf("code       =%s\n", $code);
//#printf("len(code)  =%s\n", strlen($code));

var that = this;

		var scrambled = code;

//		$scrambled = $this->scramble($code);

// #printf("scrambled  =%s\n", $scrambled);
// #printf("len(scrambled)=%s\n", strlen($scrambled));

// #printf("scrambled=%s\n", $scrambled);

		var rv = this._encode(scrambled);

// #printf("this->_totalBits=%s\n", $this->_totalBits);
// #printf("strlen(scrambled)=%s\n", strlen($scrambled));
// #printf("strlen(rv)=%s\n", strlen($rv));

// 		#$encoder = new GR_Encode();
// 		#$rv = $encoder->base2ToBase32($scrambled);
// #printf("rv         =%s\n", $rv);
// #printf("len(rv)    =%s\n", strlen($rv));
		return rv;
	},
	decodeCode: function(code) {
var that = this;
// #printf(">>> decodeCode(%s)\n", $code);
// #printf("code  =%s\n", $code);
// #printf("len(promoC)=%s\n", strlen($code));
// 
// #printf("code=%s\n", $code);

		var decoded = this._decode(code);

// #		$encoder = new GR_Encode();
// #	    $decoded = $encoder->base32ToBase2($code);
// 
// #printf("this->_totalBits=%s\n", $this->_totalBits);
// #printf("strlen(decoded)=%s\n", strlen($decoded));
	    decoded = str_pad(decoded, this._totalBits, '0', STR_PAD_LEFT);
// #printf("decoded    =%s\n", $decoded);
// #printf("len(decode)=%s\n", strlen($decoded));

//		$descrambled = $this->descramble($scrambled);

		var descrambled = decoded;

// #printf("descrambled=%s\n", $descrambled);
// #printf("len(descrambled)=%s\n", strlen($descrambled));

		var id_b = substr(descrambled, 0, this._idBits);

// #printf("id_b  =%s\n", $id_b);
		var id = base_convert(id_b, 2, 10);

// #printf("id    =%s\n", $id);

		var hash_b    = substr(descrambled, this._idBits, this._hashBits);
// #printf("hash_b     =%s\n", $hash_b);

		var hash = this.getHash(id);

// #printf("hash       =%s\n", $hash);

		if (hash_b !== hash) {
			return false;
		}

		return  id;
	},
	isValidCode: function(code) {
		var id = false;
		
		try {
			id = this.decodeCode(code);
		} catch(e) {
		}
		
		return id !== false;
	},
	_encode: function(s) {},
	_decode: function(s) {}
};

dwgr.php.GR_Auth_Url_Code = function(){
	this._bitsPerChar = 6;
};

dwgr.php.GR_Auth_Url_Code.prototype = new dwgr.php.GR_Auth_AbstractCode;

dwgr.php.GR_Auth_Url_Code.prototype._encode = function(s) {
	var encoder = new dwgr.php.GR_Encode();
	var rv = encoder.base2ToBase64(s);
	return rv;
};
	
dwgr.php.GR_Auth_Url_Code.prototype._decode = function(s) {
	var encoder = new dwgr.php.GR_Encode();
    var rv = encoder.base64ToBase2(s);
	return rv;
}

dwgr.php.GR_Auth_Promo_Code = function(){
	this._bitsPerChar = 5;
};

dwgr.php.GR_Auth_Promo_Code.prototype = new dwgr.php.GR_Auth_AbstractCode;

dwgr.php.GR_Auth_Promo_Code.prototype._encode = function(s) {
	var encoder = new dwgr.php.GR_Encode();
	var rv = encoder.base2ToBase32(s);
	return rv;
};
	
dwgr.php.GR_Auth_Promo_Code.prototype._decode = function(s) {
	var encoder = new dwgr.php.GR_Encode();
    var rv = encoder.base32ToBase2(s);
	return rv;
}



	dwgr.grutil.SystemGeneratedPassword = function(){
		this.allowedChars = 'abcdefghjkmnpqrstuvwxyz23456789'.split('');
	}
	dwgr.grutil.SystemGeneratedPassword.prototype = {
		get : function(length){
			var count = length || 8;
			var numChars = this.allowedChars.length;
			var pw = '', letter;
		
			for( var i=0, ii=count; i<ii; i++ ) {
				// Come up with a number between 0 and al
				letter = this.allowedChars[parseInt(Math.random()*numChars)];
				if( letter >= 'a' && letter <= 'z' ) {
					if( Math.random()<0.2 ) {
						letter = letter.toUpperCase();
					}
				}
				pw+=letter;
			}
		
			return pw;
		}
	};

	dwgr.grutil.SystemGeneratedUniqueID = function(){
		this.B62_GLO_timeSpan = 31536000;
		
		this.internalTime = dwgr.grutil.microtime();
		this.millisecs = parseInt(substr(this.internalTime, 2, 3));
		this.uid = substr(this.internalTime,11);
		this.secs = parseInt(this.uid) % this.B62_GLO_timeSpan;

		this.adj_date = this.secs * 1000 + this.millisecs;
	}
	dwgr.grutil.SystemGeneratedUniqueID.prototype = {
		get : function(){
			return dwgr.grutil.to_base62( this.adj_date ); 
		},
		getIntUID : function(){
			return this.uid;
		}
	};

})(dwgr);

	function ord(string) {
	    // Returns the codepoint value of a character  
	    // 
	    // version: 1109.2015
	    // discuss at: http://phpjs.org/functions/ord    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	    // +   bugfixed by: Onno Marsman
	    // +   improved by: Brett Zamir (http://brett-zamir.me)
	    // +   input by: incidence
	    // *     example 1: ord('K');    // *     returns 1: 75
	    // *     example 2: ord('\uD800\uDC00'); // surrogate pair to create a single Unicode character
	    // *     returns 2: 65536
	    var str = string + '',
	        code = str.charCodeAt(0);    if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
	        var hi = code;
	        if (str.length === 1) {
	            return code; // This is just a high surrogate with no following low surrogate, so we return its value;
	            // we could also throw an error as it is not a complete character, but someone may want to know
	        }
	        var low = str.charCodeAt(1);
	        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
	    }
	    if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate
	        return code; // This is just a low surrogate with no preceding high surrogate, so we return its value;
	        // we could also throw an error as it is not a complete character, but someone may want to know
	    }
	    return code;
	}
	
function ltrim (str, charlist) {
    // Strips whitespace from the beginning of a string  
    // 
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/ltrim    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Erkekjetter
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   bugfixed by: Onno Marsman
    // *     example 1: ltrim('    Kevin van Zonneveld    ');    // *     returns 1: 'Kevin van Zonneveld    '
    charlist = !charlist ? ' \\s\u00A0' : (charlist + '').replace(/([\[\]\(\)\.\?\/\*\{\}\+\$\^\:])/g, '$1');
    var re = new RegExp('^[' + charlist + ']+', 'g');
    return (str + '').replace(re, '');
}	
function rtrim (str, charlist) {
    // Removes trailing whitespace  
    // 
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/rtrim    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Erkekjetter
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   bugfixed by: Onno Marsman
    // +   input by: rem    // +   bugfixed by: Brett Zamir (http://brett-zamir.me)
    // *     example 1: rtrim('    Kevin van Zonneveld    ');
    // *     returns 1: '    Kevin van Zonneveld'
    charlist = !charlist ? ' \\s\u00A0' : (charlist + '').replace(/([\[\]\(\)\.\?\/\*\{\}\+\$\^\:])/g, '\\$1');
    var re = new RegExp('[' + charlist + ']+$', 'g');
    return (str + '').replace(re, '');
}
function sprintf () {
    // http://kevin.vanzonneveld.net
    // +   original by: Ash Searle (http://hexmen.com/blog/)
    // + namespaced by: Michael White (http://getsprink.com)
    // +    tweaked by: Jack
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Paulo Freitas
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Brett Zamir (http://brett-zamir.me)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: sprintf("%01.2f", 123.1);
    // *     returns 1: 123.10
    // *     example 2: sprintf("[%10s]", 'monkey');
    // *     returns 2: '[    monkey]'
    // *     example 3: sprintf("[%'#10s]", 'monkey');
    // *     returns 3: '[####monkey]'
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g;

    var a = arguments,
        i = 0,
        format = a[i++];

    // pad()
    var pad = function (str, len, chr, leftJustify) {
        if (!chr) {
            chr = ' ';
        }
        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };

    // justify()
    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify || !zeroPad) {
                value = pad(value, minWidth, customPadChar, leftJustify);
            } else {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };

    // formatBaseX()
    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var anumber = value >>> 0;
        prefix = prefix && anumber && {
            '2': '0b',
            '8': '0',
            '16': '0x'
        }[base] || '';
        value = prefix + pad(anumber.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };

    // formatString()
    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };

    // doFormat()
    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var anumber;
        var prefix;
        var method;
        var textTransform;
        var value;

        if (substring == '%%') {
            return '%';
        }

        // parse flags
        var leftJustify = false,
            positivePrefix = '',
            zeroPad = false,
            prefixBaseX = false,
            customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
            switch (flags.charAt(j)) {
            case ' ':
                positivePrefix = ' ';
                break;
            case '+':
                positivePrefix = '+';
                break;
            case '-':
                leftJustify = true;
                break;
            case "'":
                customPadChar = flags.charAt(j + 1);
                break;
            case '0':
                zeroPad = true;
                break;
            case '#':
                prefixBaseX = true;
                break;
            }
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }

        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
        } else if (precision == '*') {
            precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }

        // grab value using valueIndex if required?
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

        switch (type) {
        case 's':
            return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
        case 'c':
            return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
        case 'b':
            return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'o':
            return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'x':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'X':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
        case 'u':
            return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'i':
        case 'd':
            anumber = (+value) | 0;
            prefix = anumber < 0 ? '-' : positivePrefix;
            value = prefix + pad(String(Math.abs(anumber)), precision, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G':
            anumber = +value;
            prefix = anumber < 0 ? '-' : positivePrefix;
            method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
            textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
            value = prefix + Math.abs(anumber)[method](precision);
            return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
        default:
            return substring;
        }
    };

	var thing = format.replace(regex, doFormat);

    return thing;
}
/* 
 * More info at: http://phpjs.org
 * 
 * This is version: 3.25
 * php.js is copyright 2011 Kevin van Zonneveld.
 * 
 * Portions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld
 * (http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White
 * (http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jonas Raoni
 * Soares Silva (http://www.jsfromhell.com), Jack, Philip Peterson, Legaev
 * Andrey, Ates Goral (http://magnetiq.com), Ratheous, Alex, Rafał Kukawski
 * (http://blog.kukawski.pl), Martijn Wieringa, lmeyrick
 * (https://sourceforge.net/projects/bcmath-js/), Nate, Enrique Gonzalez,
 * Philippe Baumann, Webtoolkit.info (http://www.webtoolkit.info/), Jani
 * Hartikainen, Ole Vrijenhoek, Ash Searle (http://hexmen.com/blog/), Carlos
 * R. L. Rodrigues (http://www.jsfromhell.com), travc, Michael Grier,
 * Erkekjetter, Johnny Mast (http://www.phpvrouwen.nl), Rafał Kukawski
 * (http://blog.kukawski.pl/), GeekFG (http://geekfg.blogspot.com), Andrea
 * Giammarchi (http://webreflection.blogspot.com), WebDevHobo
 * (http://webdevhobo.blogspot.com/), d3x, marrtins,
 * http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,
 * pilus, stag019, T.Wild, Martin (http://www.erlenwiese.de/), majak, Marc
 * Palau, Mirek Slugen, Chris, Diplom@t (http://difane.com/), Breaking Par
 * Consulting Inc
 * (http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
 * gettimeofday, Arpad Ray (mailto:arpad@php.net), Oleg Eremeev, Josh Fraser
 * (http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
 * Steve Hilder, mdsjack (http://www.mdsjack.bo.it), Kevin van Zonneveld
 * (http://kevin.vanzonneveld.net/), gorthaur, Aman Gupta, Sakimori, Joris,
 * Robin, Kankrelune (http://www.webfaktory.info/), Alfonso Jimenez
 * (http://www.alfonsojimenez.com), David, Felix Geisendoerfer
 * (http://www.debuggable.com/felix), Lars Fischer, Karol Kowalski, Imgen Tata
 * (http://www.myipdf.com/), Steven Levithan (http://blog.stevenlevithan.com),
 * Tim de Koning (http://www.kingsquare.nl), Dreamer, AJ, Paul Smith, KELAN,
 * Pellentesque Malesuada, felix, Michael White, Mailfaker
 * (http://www.weedem.fr/), Thunder.m, Tyler Akins (http://rumkin.com),
 * saulius, Public Domain (http://www.json.org/json2.js), Caio Ariede
 * (http://caioariede.com), Steve Clay, David James, madipta, Marco, Ole
 * Vrijenhoek (http://www.nervous.nl/), class_exists, T. Wild, noname, Arno,
 * Frank Forte, Francois, Scott Cariss, Slawomir Kaniecki, date, Itsacon
 * (http://www.itsacon.net/), Billy, vlado houba, Jalal Berrami,
 * ReverseSyntax, Mateusz "loonquawl" Zalega, john (http://www.jd-tech.net),
 * mktime, Douglas Crockford (http://javascript.crockford.com), ger, Nick
 * Kolosov (http://sammy.ru), Nathan, nobbler, Fox, marc andreu, Alex Wilson,
 * Raphael (Ao RUDLER), Bayron Guevara, Adam Wallner
 * (http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,
 * Pyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick
 * (https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,
 * Gilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson Högfeldt
 * (http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,
 * josh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren
 * Hansen, EdorFaus, Eugene Bulkin (http://doubleaw.com/), Der Simon
 * (http://innerdom.sourceforge.net/), echo is bad, JB, LH, kenneth, J A R,
 * Marc Jansen, Stoyan Kyosev (http://www.svest.org/), Francesco, XoraX
 * (http://www.xorax.info), Ozh, Brad Touesnard, MeEtc
 * (http://yass.meetcweb.com), Peter-Paul Koch
 * (http://www.quirksmode.org/js/beat.html), Olivier Louvignes
 * (http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, nord_ua, Martin, JT,
 * David Randall, Thomas Beaucourt (http://www.webapp.fr), Tim de Koning,
 * stensi, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair
 * Research Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger
 * (http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner
 * B. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong
 * (http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,
 * Simon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,
 * Marco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke
 * (http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,
 * Evertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke
 * Godfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,
 * sowberry, Norman "zEh" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,
 * Steven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya
 * (http://www.premasolutions.com/), Philippe Jausions
 * (http://pear.php.net/user/jausions), Aidan Lister
 * (http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,
 * strcmp, Taras Bogach, jpfle, Alexander Ermolaev
 * (http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,
 * dptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha
 * (http://www.pedrotainha.com), James, Arnout Kazemier
 * (http://www.3rd-Eden.com), Chris McMacken, Yannoo, jakes, gabriel paderni,
 * FGFEmperor, Greg Frazier, baris ozdil, 3D-GRAF, daniel airton wermann
 * (http://wermann.com.br), Howard Yeend, Diogo Resende, Allan Jensen
 * (http://www.winternet.no), Benjamin Lupton, Atli Þór, Maximusya, davook,
 * Tod Gentille, Ryan W Tenney (http://ryan.10e.us), Nathan Sepulveda, Cord,
 * fearphage (http://http/my.opera.com/fearphage/), Victor, Rafał Kukawski
 * (http://kukawski.pl), Matteo, Manish, Matt Bradley, Riddler
 * (http://www.frontierwebdev.com/), Alexander M Beedie, T.J. Leahy, Rafał
 * Kukawski, taith, Luis Salazar (http://www.freaky-media.com/), FremyCompany,
 * Rival, Luke Smith (http://lucassmith.name), Andrej Pavlovic, Garagoth, Le
 * Torbi (http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,
 * Russell Walker (http://www.nbill.co.uk/), Jamie Beck
 * (http://www.terabit.ca/), setcookie, Michael, YUI Library:
 * http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at
 * http://hacks.bluesmoon.info/strftime/strftime.js, Ben
 * (http://benblume.co.uk/), DtTvB
 * (http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,
 * meo, incidence, Cagri Ekin, Amirouche, Amir Habibi
 * (http://www.residence-mixte.com/), Kheang Hok Chin
 * (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani, Tony, Yen-Wei Liu,
 * Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben Bryan
 * 
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
